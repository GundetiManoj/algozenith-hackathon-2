- partition edit3 - editor ii tcnumfl - simple numbers with fractions conversion subs - string it out tperml - permutation generator birthday - birthday pt07z - longest path in a tree polycode - polygon encoder ftour - free tour fctrl - factorial onp - transform the expression act - alpha centauri tennis mwords - matrix words harefox - hares and foxes abwords - ab-words ucube - the unstable cube pt07g - colorful lights party maze - the long and narrow maze explosn - the explosion rain2 - outside it is now raining prlgame - a game of pearls pairint - pairs of integers partit - partition edit3 - editor ii tcnumfl - simple numbers with fractions conversion subs - string it out tperml - permutation generator birthday - birthday pt07z - longest path in a tree polycode - polygon encoder ftour - free tour fctrl - factorial onp - transform the expression act - alpha centauri tennis mwords - matrix words harefox - hares and foxes abwords - ab-words ucube - the unstable cube pt07g - colorful lights party maze - the long and narrow maze explosn - the explosion rain2 - outside it is now raining prlgame - a game of pearls pairint - pairs of integers landscap - landscaping tfoss - fossil in the ice partit - partition edit3 - editor ii tcnumfl - simple numbers with fractions conversion subs - string it out tperml - permutation generator birthday - birthday pt07z - longest path in a tree polycode - polygon encoder ftour - free tour fctrl - factorial onp - transform the expression act - alpha centauri tennis mwords - matrix words harefox - hares and foxes abwords - ab-words ucube - the unstable cube pt07g - colorful lights party maze - the long and narrow maze explosn - the explosion rain2 - outside it is now raining pairint - pairs of integers landscap - landscaping tfoss - fossil in the ice logic - logic swaps - counting inversions clever - the clever typist print - prime intervals ncklce - another necklace problem aroad - another road problem pb - parking bay robot - robot number m zoo - zoo trstage - traveling by stagecoach eqdiv - equidivisions bpred - branch prediction disubstr - distinct substrings chase - a chase in wonderland palace - accomodate the palace cover - k-path cover tree1 - tree sbstr1 - substring check (bug funny) partit - partition partit - partition edit3 - editor ii tcnumfl - simple numbers with fractions conversion subs - string it out tperml - permutation generator birthday - birthday pt07z - longest path in a tree polycode - polygon encoder ftour - free tour fctrl - factorial onp - transform the expression act - alpha centauri tennis mwords - matrix words harefox - hares and foxes abwords - ab-words ucube - the unstable cube pt07g - colorful lights party maze - the long and narrow maze explosn - the explosion rain2 - outside it is now raining prlgame - a game of pearls pairint - pairs of integers landscap - landscaping tfoss - fossil in the ice logic - logic swaps - counting inversions clever - the clever typist print - prime intervals ncklce - another necklace problem aroad - another road problem pb - parking bay robot - robot number m zoo - zoo trstage - traveling by stagecoach eqdiv - equidivisions bpred - branch prediction disubstr - distinct substrings chase - a chase in wonderland partit - partition edit3 - editor ii tcnumfl - simple numbers with fractions conversion subs - string it out tperml - permutation generator birthday - birthday pt07z - longest path in a tree polycode - polygon encoder ftour - free tour fctrl - factorial onp - transform the expression act - alpha centauri tennis mwords - matrix words harefox - hares and foxes abwords - ab-words ucube - the unstable cube pt07g - colorful lights party maze - the long and narrow maze explosn - the explosion rain2 - outside it is now raining prlgame - a game of pearls pairint - pairs of integers landscap - landscaping tfoss - fossil in the ice logic - logic swaps - counting inversions clever - the clever typist print - prime intervals ncklce - another necklace problem aroad - another road problem pb - parking bay robot - robot number m zoo - zoo trstage - traveling by stagecoach eqdiv - equidivisions bpred - branch prediction disubstr - distinct substrings chase - a chase in wonderland palace - accomodate the palace cover - k-path cover tree1 - tree sbstr1 - substring check (bug funny) railroad - railroads

partition of positive integer m into n components is any sequence a1,...,an of positive integers such that a1+...+an=m and a1<=a2<=...<=an. your task is to determine the partition, which occupies the k-th position in the lexicographic order of all partitions of m into n components. the lexicographic order is defined as follows: sequence a1,...,an comes before b1,...,bn iff there exists such an integer i,1<=i<=n, that aj=bj for all j, 1<= j< i, and ai< bi. input the input begins with the integer t, the number of test cases. then t test cases follow. for each test case the input consists of three lines, containing the positive integers m, n and k respectively (1<=n<= 10, 1<= m<=220, k is not larger than the number of partitions of m into n components). output for each test case output the ordered elements of the sought partition, separated by spaces. example sample input: 1 9 4 3 sample output: 1 1 3 4
most important part of a gsm network is so called base transceiver station (bts). these transceivers form the areas called cells (this term gave the name to the cellular phone) and every phone connects to the bts with the strongest signal (in a little simplified view). of course, btses need some attention and technicians need to check their function periodically. acm technicians faced a very interesting problem recently. given a set of btses to visit, they needed to find the shortest path to visit all of the given points and return back to the central company building. programmers have spent several months studying this problem but with no results. they were unable to find the solution fast enough. after a long time, one of the programmers found this problem in a conference article. unfortunately, he found that the problem is so called "travelling salesman problem" and it is very hard to solve. if we have n btses to be visited, we can visit them in any order, giving us n! possibilities to examine. the function expressing that number is called factorial and can be computed as a product 1.2.3.4....n. the number is very high even for a relatively small n. the programmers understood they had no chance to solve the problem. but because they have already received the research grant from the government, they needed to continue with their studies and produce at least some results. so they started to study behaviour of the factorial function. for example, they defined the function z. for any positive integer n, z(n) is the number of zeros at the end of the decimal form of number n!. they noticed that this function never decreases. if we have two numbers n1<n2, then z(n1) <= z(n2). it is because we can never "lose" any trailing zero by multiplying by any positive number. we can only get new and new zeros. the function z is very interesting, so we need a computer program that can determine its value efficiently. input there is a single positive integer t on the first line of input (equal to about 100000). it stands for the number of numbers to follow. then there are t lines, each containing exactly one positive integer number n, 1 <= n <= 1000000000. output for every number n, output a single line containing the single non-negative integer z(n). example sample input: 6 3 60 100 1024 23456 8735373 sample output: 0 14 24 253 5861 2183837
the algebraic expression with brackets into rpn form (reverse polish notation). two-argument operators: +, -, *, /, ^ (priority from the lowest to the highest), brackets ( ). operands: only letters: a,b,...,z. assume that there is only one rpn form (no expressions like a*b*c). input t [the number of expressions <= 100] expression [length <= 400] [other expressions] text grouped in [ ] does not appear in the input file. output the expressions in rpn form, one per line. example input: 3 (a+(b*c)) ((a+b)*(z+x)) ((a+t)*((b+(a+c))^(c+d))) output: abc*+ ab+zx+* at+bac++cd+^*
you may know, planets of alpha centauri (if they indeed do exist) would provide excellent conditions for intelligent life forms. it is indeed true that there is a small earthlike planet near alpha centauri, inhabited by a population of no particular significance. these humanlike creatures have much in common with us. living in similar comunities and having similar body structure and behavioral patterns, they unsurprisingly appreciate (approximately) the same time-killing activities as we do. one of these, the second most popular after alpha centauri croquet, is the alpha centauri tennis. although its rules differ from earth tennis, the two player version of alpha centauri tennis resembles it in many ways. same as earth tennis, it is played on a rectangular court divided into two parts by a net. two players, standing on opposite sides of it, use a stringed racket to hit a ball back and forth to each other. there are certain rules how to hit the ball. the player who forces his opponent to violate one of these rules wins the current ball. the aim of both players is to win enough balls to win a game, enough games to win a set and enough sets to win the whole match. in the n player version of the alpha centauri tennis a ball can be won by any one of the n players. although technical details of this can be difficult to imagine, alpha centaurians are extremely inventive. in the general n-player version, players serve in turns, following order determined before the match. moreover, they shift when starting individual games and sets. for example, the players are a, b and c. they are ordered alphabetically. player a serves the first ball of the first game. when the ball is won by one of the players, its b's turn to serve. after the game is won by one of the players, player b starts the second game. finally, when the first set is won by someone, player b starts the second set. this repeats, always shifted by one player, until the match ends. for three players the serving order looks as follows: set 1: game 1: a,b,c,a,b,c... game 2: b,c,a,.... game 3: c,a,b,.... game 4: a,b,c,.... ... set 2: game 1: b,c,a,b,.... game 2: c,a,b,.... game 3: a,b,c,a,... ... there are exact rules for counting the number of balls/games/sets won by a player. rules for winning a game the state of a game can be described by assigning a non-negative number of points to each of the players. at the beginning of a game, the score of each player is zero. note: in earth terminology, 0 points is called "love", 1 point is a "fifteen", 2 points is a "thirty", 3 points is a "forty" and 4 points is an "advantage". be glad that you don't have to learn the centaurian terminology :) when a player p just won a ball, the new score is determined by using the first rule from the list that applies to the situation. if p currently has 3 points and no other player has more than 2 points, p wins the current game. if p currently has 4 points, he wins the game. if any other player currently has 4 points, that player loses one point. p gains a point. rules for winning a set the set is won by the first player that at the same time: won at least 6 games in this set won at least 2 games more than any other player rules for winning a match the winner is the first player to win at least three sets. a set in which no other player won a game counts as two won sets. problem specification an observer from the intergalactic tennis federation was watching a tournament in alpha centauri tennis. being unable to understand alpha centaurian language, he only managed to write down the winner of each ball. now, for each match, knowing the sequence in which the players were winning the balls, he would like to somehow determine its winner. input t - the number of test cases [t <= 150] than t test cases follows, each corresponding to one match. each line contains the number of players n [n <= 10] and a string s consisting of uppercase letters [2 <= s <= 50000]. the players are represented by the first n letters of the english alphabet. if the i-th letter of s is x, it means the player x won the i-th ball from the beggining of the match. you may assume that the match transcripts are correct and complete. the order in which the players serve is the same as the order of their letters in the english alphabet. output for each line, output a single character, being the letter of the player who won the corresponding match. example input: 1 3 bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb output: b (b has won two sets, each of them by winning 6 games, while a and c won none. thus each of these sets counts as two and b has won the match.)
an nxn matrix of characters. we start at position (1,1) and want to reach (n,n) in exactly 2n-1 moves. each move consists of movement in one of the four standard directions. as we move, we collect the characters found in our positions forming a string. we now constrain our attention to all paths that do not cross the diagonal of the matrix. however the parts of the path can be on the diagonal line. these paths can be classified into two partitions; the paths that lie above and paths that lie below the diagonal. each path is represented by a string of characters formed by the ordered concatenation of characters found on the way. if we consider the set of all valid paths, (both upper and lower) get their corresponding strings, sort them all in alphabetical order, we obtain the (ordered) master set. note that the master set might contain duplicates, and all strings in the master set consist of exactly 2n-1 characters. let m be the total number of strings in the master set, given an integer i, we need to find the string with index = i (modulo m) within the master set. if master set = { “a”,”b”,”b”,”c” } (although this set can never be a master set!) i=0 produces “a”, while i=2 and i=5, produces “b”. constraints: n<=30. i<=1018. ‘i’ will fit into a 64-bit integer. input t-number of test cases n i next is the nxn matrix of characters, n characters per line. all characters are between ‘a’-‘z’ (only uppercase). output for each test case output the corresponding string sought for in the master set. example sample input: 2 3 18 daa bda bbd 3 18 daa ada aad sample output: dbbbd dadad explanation: test case i: master set = { “daaad”, “dadad”,”dbbbd”,”dbdbd”} test case ii: master set = { “daaad”,”daaad”,”dadad”,”dadad”}
antique comedians of malidinesia play an interesting comedy where many animals occur. because they want their plays to be as true as possible, a specialist studies the behaviour of various animals. recently, he is interested in a binary dynamic ecological system hares-foxes (shf). as a part of this project, you are asked to design and implement intelligent automatic target evaluation simulator (iates) for this system. the behaviour of the shf follows so called standard model, described by the following set of difference equations. hy+1 = a.hy - b.fy fy+1 = c.fy + d.hy where hy resp. fy represent the difference of the number of hares resp. foxes in year y and the reference count determined at the beginning of the experiment. the units of hy and fy are unknown. therefore, hy and fy are to be treated as real numbers. your task is to write a program to determine the long term evolution of shf. input the input consists of n cases (equal to about 5000). the first line of the input contains only positive integer n. then follow the cases. each case consists of six real numbers a, b, c, d, h1998 and f1998, written in this order on three lines, two numbers per line, separated by one or more spaces. the numbers are given in the classical format, i.e. optional sign, sequence of digits, optional dot and optional sequence of digits. the text form of a number does not exceed 10 characters. each case is followed by one empty line. output for each case, print one of the following sentences: 'ecological balance will develop.' - if after sufficiently long time the population of both hares and foxes approaches the reference count with an arbitrary a priori given precision, i.e. lim hy=0 and lim fy=0. 'hares will die out while foxes will overgrow.' - if after sufficiently long time the population of hares resp. foxes falls under resp. exceeds any a priori given threshold, i.e. lim hy=-infinity and lim fy=+infinity. 'hares will overgrow while foxes will die out.' - if after sufficiently long time the population of foxes resp. hares falls under resp. exceeds any a priori given threshold, i.e. lim hy=+infinity and lim fy=-infinity. 'both hares and foxes will die out.' - if after sufficiently long time the population of both hares and foxes falls under any a priori given threshold, i.e. lim hy=-infinity and lim fy=-infinity. 'both hares and foxes will overgrow.' - if after sufficiently long time the population of both hares and foxes exceeds any a priori given threshold, i.e. lim hy=+infinity and lim fy=+infinity. 'chaos will develop.' - if none of the above mentioned description fits. example sample input: 2 2 0.5 0.5 0.6 2 3 0.1 1 2 0.1 1 1 sample output: both hares and foxes will overgrow. hares will die out while foxes will overgrow.
sequence of small letters a and b (also the empty sequence) is called an ab-word. if x = [x1, ..., xn] is an ab-word and i, j are integers such that 1 <= i <= j <= n then x[i..j] denotes the subword of x consisting of the letters xi, ..., xj. we say that an ab-word x = [x1..xn] is nice if it has as many letters a as b and for all i = 1, ..., n the subword x[1..i] has at least as many letters a as b. now, we give the inductive definition of the similarity between nice ab-words. every two empty ab-words (i.e. words with no letters) are similar two non-empty nice ab-words x = [x1, ..., xn] and y = [y1, ..., ym] are similar if they have the same length (n = m) and one of the following conditions if fulfilled: x1 = y1, xn = yn and x[2..n-1] and y[2..n-1] are similar ab-words and they are both nice; there exists i, 1 <= i <= n, such that x[1..i], x[i+1..n] are nice ab-words and y[1..i], y[i+1..n] are nice ab-words and x[1..i] is similar to y[1..i] and x[i+1..n] is similar to y[i+1..n], or y[1..n-i], y[n-i+1..n] are nice ab-words and x[1..i] is similar to y[n-i+1..n] and x[i+1..n] is similar to y[1..n-i]. a level of diversity of a non-empty set s of nice ab-words is the maximal number of ab-words that can be chosen from s in such a way that for each pair w1,w2 of chosen words, w1 is not similar to w2. task write a program that for each test case: reads elements of s from standard input; computes the level of diversity of the set s; writes the result to standard output. input the number of test cases t is in the first line of input, then t test cases follow separated by an empty line. in the first line of a test case there is a number n of elements of the set s, 1 <= n <= 1000; in the following n lines there are elements of the set s, i.e. nice ab-words (one word in each line); the first letter of every ab-word is the first symbol in line and there are no spaces between two consecutive letters in the word; the length of every ab-word is an integer from the range [1..200]. output for each test case your program should output one line with one integer - the level of diversity of s. example sample input: 1 3 aabaabbbab abababaabb abaaabbabb sample output: 2
large cube (of size nxnxn) is given. at the beginning it consists of small blocks (1x1x1) and each block is painted in some color (different blocks may have the same color). but in the process of exploitation some blocks have disappeared. given 6 photos of the unstable cube you have to calculate the maximum possible number of blocks that still remain in the unstable cube. it is possible that the unstable cube consists of more than one part. input t â€“ the number of test cases, then t test cases follow. n - size of the big cube [1 <= n <= 10] in the next n lines views of the cube from 6 sides are described (in the following order: from the front, left, back, right, from above, from below). each such view is represented by a table of size nxn in which different letters denote different colors, and the symbol "." (point) means that it is possible to see all the way through the cube at this point. consecutive views are separated by exactly one space. the bottom border of the top view corresponds to the top border of the front view, and the top border of the bottom view - to the bottom border of the front view. for the front, back, left and right views the top and bottom sides of a view correspond to the top and bottom of the cube. the input file is correct, i.e. each test case describes a possible configuration. output for each test case output one integer: the required maximum number of blocks remaining in the unstable cube. example input: 2 3 .r. yyr .y. ryy .y. .r. grb ygr byg rby gyb grb .r. yrr .y. rry .r. .y. 2 zz zz zz zz zz zz zz zz zz zz zz zz output: 11 8
and his friends want to open a party to celebrate the good result of thu in icpc 2007. they will use all halls in thu for their party. there are 2 kinds of hall: the small and the large one. in each hall, there is an electronic light system, which forms a tree topology to reduce redundant wires. in a small hall, the light system is a general tree with n lights. the lights are numbered from 1 to n in a large hall, the light system is obtained from k chains of lights, each chain has length t. the first lights of these k chains are connected with a big light at the central stage of the hall. the big light has id 1, the first light of each chain has id from 2 to k+1, then we continue with the second light of each chain, so on... take a look at the figure below: acrush hopes in every hall, each light has an unique color and so do the wires! for easier to remember and to hang up lights against the walls, he sets a rule: for each hall, we number the color from 0 to n-1, so each light will get a color id in set {0, 1, ..., n-1}. color id of the wire connects i-th light and j-th light uniquely identified by the positive difference between color ids of i-th light and j-th light. at first view, the rule seems easy, so everyone agrees with him. but it's really tough if the room is quite large, too hard to set colors for lights. after few seconds, acrush says "so in this hall, the 1-st light should have color 3, the 2-nd one should have color 0,...". well, how can he do it very fast? how about you ? let write a program to help acrush's friends setting colors for lights in all t halls. input the first line of file is t -- number of halls in thu (0 < t <= 10). the following line is blank. then, there are the descriptions of t halls. for each hall, the first line contains one integer kind. kind denotes which kind of the current hall: 1 is a small hall, 2 is a large one. on next line, there are two cases: for kind 1, first line is n (1 <= n <= 27) -- number of lights. next n - 1 lines describe wires in this hall. each line is pair (u, v) -- there is a wire between light u and v (1 <= u, v <= n). for kind 2, only one line contains two numbers k and t (1 <= k, t <= 1000). there is a blank line after each description. output for each hall, show us n numbers on one line, i-th number is the color id of i-th light. if there are many solutions any of them will be accepted. otherwise, if there is no solution, all color id should be -1. the color ids on one line are separated by exactly one blank, and you'd better not print any redundant blanks. there is no blank line after each case. example input: 2 1 3 1 2 2 3 2 2 1 output: 0 2 1 0 4 2 1 3
a maze consisting of 3 rows of n square blocks each. the passageways in every block match one of three possible patterns, numbered 0 (empty), 1 (straight) and 2 (bent), as depicted below. your task is to determine whether it is possible to create a passage in a given maze, with an entrance at the left end and an outlet at the right end of the maze, only by rotating some of the squares of the maze by a multiple of 90 degrees. input the input begins with the integer t, the number of test cases. then t test cases follow. each test case begins with a line containing a single integer n - the number of squares in one row of the maze (1<= n <= 200000). the next n lines contain three integers each, denoting the types of blocks in consecutive columns of the maze. a column description is of the form a b c (0<=a,b,c<=2), where a represents the type of the block in the first row, b - in the second row and c - in the third row. output for each test case output the word yes if it is possible to rotate the squares so as to form a connection between the left and right edge, and the word no in the opposite case. example sample input: 1 6 1 0 1 1 2 2 2 2 1 2 2 1 2 2 1 1 2 2 sample output: yes indeed, the sample input corresponds to the following maze: for which there exists a correct solution to the problem: warning: large input/output data, be careful with certain languages
day of 6.xii.2003 in megabyteland began calm and quietly as any other day. some people went to work, some - to school, some - to store to buy food. drivers were traditionally stuck in traffic jams, drinking coffee and reading morning newspaper. suddenly the regularity of this day was disturbed by huge explosion. "they blew up the embassy of bajtocja!!!" - somebody cried. everybody began to run away in panic. police works pretty good in megabyteland and first radiocars appeared near the embassy only few seconds after the explosion. all the people near the embassy were detained. some of these people are the organizers of the explosion, but the others could by just occasional witnesses. during the testification each person named exactly one perpetrator. it is known, that if a man is not a perpetrator, than he always says the truth (he haven't a reason to lie, have he?). however, perpetrators want to make the work of the police more difficult, so a perpetrator can name any person during the testification (even himself). the policemen are in the very hard situation. they should arrest some group of potential perpetrators, but it is difficult to determine who is guilty and who is not from the data they have. there exists many groups of potential perpetrators, that don't contradict to any of the testimonies. the policemen want to arrest as small innocent people as possible. so they would like to choose the group with minimal number of people. write a program that, given the number of detained people and their testimonies, will determine the number of people in the smallest group of potential perpetrators, that don't contradict to the testimonies. input the first line of the input contains a single integer t, the number of testcases (1<=t<=10). first line of each testcase contains integer number n (2 <= n <= 100000), equal to the number of detained people (the people are numbered from 1 to n). the i-th of the following n lines contain one integer number pi (1 <= pi <= n). here pi is the man whom i-th man testified to be guilty. output the output should consist of t lines, containing one integer number for each testcase - the number of people in the smallest group of potential perpetrators, that don't contradict to the testimonies. example input: 1 3 2 3 1 output: 2
after trying to solve problem edit1(editor) and being ****ed by brainf**k, blue mary decided to set another difficult problem about editor. description some definitions: text: it's a sequence that consists characters whose ascii code is in [32,126]. cursor: it's a sign for pointing out the current position. it can be at the start or the end of the text or between two consecutive characters of the text. editor is a structure. it contains one text and one cursor. the operations are listed below: -------------------------------------------------------------------------- | name | input format | function | -------------------------------------------------------------------------- | move(k) | move k | move the cursor after the kth character | | | | in the text. if k=0, you should put | | | | the cursor at the start of the text. | -------------------------------------------------------------------------- | insert(n,s) | insert n s | insert string s whose length is n(>=1) | | | | after the cursor. the cursor doesn't move.| -------------------------------------------------------------------------- | delete(n) | delete n | delete n(>=1) characters after the cursor.| | | | the cursor doesn't move. | -------------------------------------------------------------------------- | get(n) | get n | output n(>=1) characters after the cursor.| -------------------------------------------------------------------------- | prev() | prev | move the cursor one character backward. | -------------------------------------------------------------------------- | next() | next | move the cursor one character forward. | -------------------------------------------------------------------------- if the text of a editor is empty, we say the editor is empty. here is an example._ denotes to the cursor,$ denotes to the start and the end. at start the editor is empty. ------------------------------------------------------------------------------ | operation | text after the operation | output | ------------------------------------------------------------------------------ | insert(13,"balanced tree") | $_balanced tree$ | $$ | ------------------------------------------------------------------------------ | move(2) | $ba_lanced tree$ | $$ | ------------------------------------------------------------------------------ | delete(5) | $ba_d tree$ | $$ | ------------------------------------------------------------------------------ | next() | $bad_ tree$ | $$ | ------------------------------------------------------------------------------ | insert(7," editor") | $bad_ editor tree$ | $$ | ------------------------------------------------------------------------------ | move(0) | $_bad editor tree$ | $$ | ------------------------------------------------------------------------------ | get(15) | $_bad editor tree$ | $bad editor tree$ | ------------------------------------------------------------------------------ your task is: build an empty editor. read some operations from the standard input and operate them. for each get operation, write the answer to the output. input the very first line contains the number of testcases t(t<=4).t tests follow. for each test, the first line is the number of operations n.n operations follow. blue mary is so depressed with the problem edit1 that she decides to make the problem more difficult. so she inserts many extra line breaks in the string of the insert operation. you must ignore them. except line breaks, all the characters' ascii code are in [32,126]. there's no extra space at the end of a line. you can assume that for each test case: no invalid operation is in the input. number of move operations is no more than 50000. number of the total of insert and delete operations is no more than 4000. number of the total of prev and next operations is no more than 200000. the characters inserted will not more than 2mb.the valid output will not more than 3mb. output the output should contain t blocks corresponding to each testcase. for each test case, the output should contain as many lines as the get operations in the input. each line should contains the output of each get operation. example input: 1 15 insert 26 abcdefghijklmnop qrstuv wxy move 15 delete 11 move 5 insert 1 ^ next insert 1 _ next next insert 4 .\/. get 4 prev insert 1 ^ move 0 get 22 output: .\/. abcde^_^f.\/.ghijklmno warning: large input/output data, be careful with certain languages
m is pluvian. in city p, it rains frequently and many people complain that they always have trouble crossing the streets when raining. to make people cross the streets easier, the government set many "automatic umbrellas" above every crosswalk, shown in the picture below. each of these "automatic umbrellas" looks like a rectangle board, and their thickness is approximate zero. they can sop up the rain instantly. they are left unused when it's not raining and shuttle from one side to another in the same speed otherwise. the walkers will not be wringing-wet if he walks under the umbrella when it's raining. when many people want to cross the street, one "automatic umbrella" is not enough obviously. the government set many "automatic umbrella" on some main crosswalks. the width of each of the "automatic umbrella" equals to the width of the crosswalk, and any two of these umbrellas have different height. their length and speed may be different. you are to write a program to calculate the total volume of the rain falling to the ground from the time when it starts to rain to t seconds later. input the very first line comes a single integer q, the number of test cases. q blocks follow. for each test case: the first line contains 4 space-separated integers n (<=10), w (<=100), t (<=100), v (<=50), the number of "automatic umbrella", the length of the crosswalk in meters, the total time in seconds and the volume of rain falling to the ground per square meter per second. to simplify the description, we can build a cartesian coordinate system in the following way: let the left side of the street be the origin, the street be the positive ox-axes, and the vertical line to the ground be the positive oy-axes, see the picture below. each of the next n lines contains 3 integers xi, li, vi, the initial position(in meter), the length(in meter), the speed(in meter per second) of the i-th umbrella. if vi>0, the umbrella moves to the right side initially; if vi<0, the umbrella moves to the left side initially; if vi=0, the umbrella doesn't move at all. you can assume that the width of the umbrella and the crosswalk is 1 meter, the rain falls vertically, the speed of the rain will not change and the umbrellas and the crosswalk are absolutely horizontal. output for each test case, you should output a single real number(rounded to 2 decimal places) - the answer. you can assume the total distance of all the umbrella's movement will not exceed 550*w. example input: 1 2 4 3 10 0 1 1 3 1 -1 output: 65.00
game of pearls is to use the following 12 kinds of pearl designs each one and only one time to make the big pearl design.the pearl designs can be rotated and turned over arbitrarily. see the pictures below. the empty grids a sample big pearl design a sample big pearl design used characters instead of colors part a part b part c part d part e part f part g part h part i part j part k part l input ten test cases(given one after another,you have to process all!), each contains a big design, 'a'-'l' denote the filled grids, '.' denotes the empty grids,see the example. you can assume that the pearl designs used are completely put into the empty grids. output a big design which has no grids that haven't been filled and each pearl design is used one and only one time in it,or 'no solution'(without quotes) if there's no solution.if there are multiple solutions,output any. example input: . .. ... .... ..... .....c ...ccc. eeehh... e.hhh.... e......... [and 9 test cases more] output: b bk bkk bjkk jjjdd gjgddc gggccci eeehhiia elhhhiaaf elllliffff [and 9 test cases more]
are to find all pairs of integers such that their sum is equal to the given integer number n and the second number results from the first one by striking out one of its digits. the first integer always has at least two digits and starts with a non-zero digit. the second integer always has one digit less than the first integer and may start with a zero digit. input the first line of the input file is the integer number t ( 1 ≤ t ≤ 20 ), the number of test cases. then t lines follow, each test case in one line; the line consists of a single integer n (10 ≤ n ≤ 10^9). output for each test case: on the first line write the total number of different pairs of integers that satisfy the problem statement. on the following lines write all those pairs. write one pair on a line in ascending order of the first integer in the pair. each pair must be written in the following format x + y = n here x, y, and n, must be replaced with the corresponding integer numbers. there should be exactly one space on both sides of '+' and '=' characters. example input: 2 302 11 output: 5 251 + 51 = 302 275 + 27 = 302 276 + 26 = 302 281 + 21 = 302 301 + 01 = 302 1 10 + 1 = 11
john is making the difficult transition from raising mountain goats to raising cows. his farm, while ideal for mountain goats, is far too mountainous for cattle and thus needs to be flattened out a bit. since flattening is an expensive operation, he wants to remove the smallest amount of earth possible. the farm is long and narrow and is described in a sort of two-dimensional profile by a single array of n (1 <= n <= 1000) integer elevations (range 1..1,000,000) like this: 1 2 3 3 3 2 1 3 2 2 1 2, which represents the farm's elevations in profile, depicted below with asterisks indicating the heights: * * * * * * * * * * * * * * * * * * * * * * * * * 1 2 3 3 3 2 1 3 2 2 1 2 a contiguous range of one or more equal elevations in this array is a "peak" if both the left and right hand sides of the range are either the boundary of the array or an element that is lower in elevation than the peak. the example above has three peaks. determine the minimum volume of earth (each unit elevation reduction counts as one unit of volume) that must be removed so that the resulting landscape has no more than k (1 <= k <= 25) peaks. note well that elevations can be reduced but can never be increased. if the example above is to be reduced to 1 peak, the optimal solution is to remove 2 + 1 + 1 + 1 = 5 units of earth to obtain this set of elevations: * * * - * * * * * - - - - * * * * * * * * * * * * 1 2 3 3 3 2 1 1 1 1 1 1 where '-'s indicate removed earth. input the first line of the input contains integer t representing the number of test cases. then t test cases follow. each test case has the following form: line 1: two space-separated integers: n and k lines 2..n+1: each line contains a single integer elevation. line i+1 contains the elevation for index i. output for each test case, output the minimum volume of earth that must be removed to reduce the number of peaks to k. example input: 1 12 1 1 2 3 3 3 2 1 3 2 2 1 2 output: 5 input details this is the example used above.
small group of archaeologists is working in the antarctic. their sensors have detected a number of caves in which there are interesting fossils. however, a thick layer of ice blocks the entrance to each cave. the archaeologists possess the equipment needed to burn a tunnel in the layer of ice, but the fuel is extremely expensive. in order to determine the size of each fossil the group has launched a number of probes through small bore-holes. each probe which hit the fossil emits a signal consisting of its x and y coordinates. your task is to determine the smallest possible size of the tunnel, which is equal to the maximal distance between any two probes (so that the fossil wonâ€™t be damaged during extraction). the drilling equipment needs to be provided with the squared value of this distance. given the list of coordinates of the points containing probes, find the square of the maximal distance between any two probes. input t [the number of tests <= 20] [empty line] n [the number of active probes <= 100000] x1 y1 [coordinates of the first probe] ... xn xn [integer coordinates from -50000000 to 50000000] [empty line] [input for the next test cases...] text grouped in [ ] does not appear in the input file. output o1 [the square of the maximal distance in the first set] [output for the next test cases...] example input: 5 1 2 -3 4 0 0 -2 2 2 2 1 0 6 -4 2 2 2 5 0 0 5 6 1 -1 -1 10 0 0 5 1 9 2 12 3 14 4 15 5 16 7 17 10 18 14 19 19 10 2 -3 -1 2 0 5 -5 -1 -4 2 4 0 1 3 4 3 -3 -4 0 -2 output: 0 16 101 722 98
a 10x10 grid. cells in this grid can contain one of five logic operations (and, or, not, input, output). these can be joined together to form a logic circuit. given a description of a circuit and a set of boolean values, build the logic circuit and execute the input stream against it. input the first line of the input contains a single integer n, which specifies the number of circuits to be processed. there will then be n groups of circuit descriptions and test values. a circuit is made up of a number of operations. each line describing an operation begins with three characters: the co-ordinates for a cell, 0-9 on the x-axis then 0-9 on the y-axis, followed by a single character to represent the operation of that cell ('&' for and, '|' for or, '!' for not, 'i' for input and 'o' for output). optionally following each triple is a set of co-ordinate pairs which represent the x and y co-ordinates of cells that take the output of this cells operation as an input for theirs. this (possibly empty) output list is terminated by '..'. the list of operations is terminated by a line containing the word 'end'. next, for each circuit, comes the set of test values. the first line contains an integer t which gives the number of test cases your program must run. next, there are t lines, each line containing a sequence of '0' and '1' characters symbolising the input values for one test case. the number of inputs will always correspond to the number of inputs defined by the circuit description. the input values are to be applied to the inputs in the order in which the input operations were defined in the circuit description. the next circuit description, if any, will then follow. output for each circuit, your program should output one line for each test case given in the input. the line should contain one '0' or '1' character for each output defined by the circuit description in the order in which the outputs were defined. your program should output a blank line after each set of test cases. example input: 1 00i 11 13 .. 02i 11 13 .. 11& 21 .. 21o .. 13| 23 .. 23o .. end 4 00 01 10 11 output: 00 01 01 11 notes: i, o and ! operations will always have exactly one input. & and | operations will always have exactly two inputs. even if an operation can feed others, it does not have to. no recursive circuits. o can also be an input for another gate hint: sample input specifies a circuit consiting of an 'and' and an 'or' operation in parallel both fed from the same two inputs: +---------\ 3 | |or #----------out(2) | +---/ | | 2 in(2)----+ | | | +---------\ 1 | |and#----------out(1) +---/ | 0 in(1)---------+ 0 1 2 in grid terms this is two inputs at 0,0 and 1,0. the first input feeds the and operation at 1,1 and the or operation at 1,3. the second input operation feeds the second input for the same and and or operations. the and operation then feeds an output operation at 2,1. the or operation also feeds an output operation, this one at 2,3.
are given a sequence a of n (n≤250000) integers between 1 and 50000. on this sequence you have to apply m (m≤10000) operations of the form: modify the i-th element in the sequence and then say how many inversions are there in the sequence. the number of inversions in a sequence is given by the number of pairs (i, j) with i < j and ai > aj. input the first line of input contains the number n and the next line contains the numbers that form the sequence. after that follows the number m and then m lines, each containing 2 integers x and y, meaning that new value of the x-th element of the sequence is y and that you should count the number of inversions in the modified sequence. output output must contain m lines, the i-th line of output containing the number of inversions in the sequence after the first i operations. example input: 10 2 6 6 4 7 6 3 5 9 1 7 8 8 5 1 5 6 10 5 7 1 10 10 4 6 output: 17 18 16 13 14 8 6
mary is a typist of some secret department.now she has to type in many passwords in an hour,each of which has a fixed length: 6.of course,the less times she presses the keyboard,the happier she is. unfortunately,the keyboard to type in the password is extraordinary designed to keep secrets.the keyboard has 6 particular keys instead of 10 number keys.to explain the usages of these keys,let's define the 6 position on the screen 1,2,3,4,5,6 from left to right.the keys' usages are shown below: swap0: swap the digit in the cursor position and the digit in position 1.the cursor doesn't move.if the cursor is now in position 1,the digits on the screen won't be changed. swap1: swap the digit in the cursor position and the digit in position 6.the cursor doesn't move.if the cursor is now in position 6,the digits on the screen won't be changed. up: increase the digit in the cursor position by 1.if the digit in the cursor position is 9,no change will happen. down: decrease the digit in the cursor position by 1.if the digit in the cursor position is 0,no change will happen. left: move the cursor one position left.if the cursor is in position 1,no change will happen. right: move the cursor one position right.if the cursor is in position 6,no change will happen. at start,6 random digits will be given on the screen,and the cursor will in position 1.after some smart presses,she can type in the correct password,at that time the cursor position is unimportant. here is an example("()"denotes to the cursor): key pressed screen (1)23456 swap1 (6)23451 right 6(2)3451 swap0 2(6)3451 down 2(5)3451 right 25(3)451 up 25(4)451 right 254(4)51 down 254(3)51 right 2543(5)1 up 2543(6)1 swap0 6543(2)1 now mary wants to know the minimal number of keys she has to press.can you help her? input the first line contains a single integer t(about 1000).t lines follow,each contains two 6-digit string,which show the digits on the screen at start and the password mary is to type in,separated by a single space. output t lines,each contains a single integer - the answer. example sample input: 1 123456 654321 sample output: 11 added some new test data.
this problem you have to print all primes from given interval. input t - the number of test cases, then t lines follows. [t <= 150] on each line are written two integers l and u separated by a blank. l - lower bound of interval, u - upper bound of interval. [2 <= l < u <= 2147483647] [u-l <= 1000000]. output for each test case output must contain all primes from interval [l; u] in increasing order. example input: 2 2 10 3 7 output: 2 3 5 7 3 5 7
corporation is a company which produces colorful necklaces. the necklaces designed by them are unique and fashionable, and because of the price, they are popular with the youth. now, t corporation intends to design a self-help producing system. this system includes hardware and software. the software is interactive and controls the hardware. now the hardware has been completed, but the software is to develop. the workers find you, who is taking noi. could you please write a software system to simulate? a necklace includes n beads. the color of each bead is one of 1..c. the necklace is fixed in a plain. one position of the plain is marked as position 1, and the other positions are marked as 2..n in clockwise. your system should supply the orders as follow: +------------+-------------------------------+--------------------------------------------------+ |order |parameters restrictions |content | +------------+-------------------------------+--------------------------------------------------+ |r k |0 < k < n |it means rotate k. rotate the necklace by k | | | |positions in clockwise. i.e. the bead in former 1 | | | |position will be transfer to position k+1, the | | | |bead in former 2 position will be transfer to | | | |position k+2, and so on. | +------------+-------------------------------+--------------------------------------------------+ |f | |it means flip. flip the plain by the given axis. | | | |the bead in position 1 doesn't move.the bead in | | | |position 2 will swap with the bead in position | | | |n,the bead in position 3 will swap with the bead | | | |in position n-1, and so on. | +------------+-------------------------------+--------------------------------------------------+ |s i j |1 <= i,j <= n |swap the bead in position i and j. | +------------+-------------------------------+--------------------------------------------------+ |p i j x |1 <= i,j <= n , x<= c |it means paint. paint color x from position i to | | | |position j in clockwise. | +------------+-------------------------------+--------------------------------------------------+ |c | |it means count. ask how many parts are there in | | | |the necklace. we define some consecutive beads | | | |in same color as a "part". pay attention that c is| | | |different from cs 1,n. | +------------+-------------------------------+--------------------------------------------------+ |cs i j |1 <= i,j <= n |it means countsegment i,j. ask how many parts are | | | |there from position i to position j in clockwise, | | | |i and j included. | +------------+-------------------------------+--------------------------------------------------+ input the first line in input includes two integers n,c, representing the beads in the necklace and the number of colors. the second line contains n integers x1,x2...xn, representing the colors of beads from position 1 to position n,1<=xi<=c. the third line includes a integer q, as the number of orders. there is an order in the next q lines, as mentioned above. for 60% test cases, n <= 1000, q <= 1000; for 100% test cases, n <= 500000, q <= 500000. output for every order starts with c and cs, print a integer as the answer. example input: 5 3 1 2 3 2 1 4 c r 2 p 5 5 2 cs 4 1 output: 4 1 test data is unofficial. if you have any questions, please contact me.
integer number n is represented in positional number system of base r by a sequence of digits 0 <= di < r, decimal point ',' and fractional part, so the value is equal to: n = d0 + r * d1 + r2 * d2 + r3 * d3 + ... + r-1 * d-1 + r-2 * d-2 + r-3 * d-3 + ... your task is to convert a given number in r-base representation into s-base representation with l digits after decimal point (no rounding - use floor), for example: decimal 231,5 into binary 11100111,1 with one digit after decimal point. assume that r <= 36 and the digits are 0,1,2,3,4,5,6,7,8,9, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z. input n [the number of series <= 1000] n r s l [n < 361000 + 1, r,s <= 36, l <= 1000 ] output n [s-base representation of number n] text grouped in [ ] does not appear in the input and output file. example input: 10 500,1 6 31 3 3866,dj 22 27 1 eh75,l3 24 4 3 a73c,10b 13 27 2 6c6j,e483 22 6 2 ja,l 30 5 4 6,5a 20 31 2 1,c5 14 7 1 hd,6k 26 9 2 1001,011 2 10 3 output: 5p,555 1m8h,h 301223231,320 14mb,25 1255211,35 4310,3222 6,8g 1,6 555,23 9,375
let's say you are given a set of cities (numbered from 1 to n) and possible bidirectional roads between them. you would like to build cheapest road network that will make getting from the capital (which has number 1) to every other city possible, where the cost of the network is just sum of its roads' costs. seems easy? well, it certainly would be too easy and boring, so this time you should satisfy one additional constraint: you must consider only networks in which there are at most d roads outgoing from the capital. input first line of input contains number of test cases c (1<=c<=40). each test case begins with number of cities n, number of possible roads m and maximum degree d (1<=n<=1000, 0<=m<=100000, 0<=d<=100). then m lines describing roads follow, each of them containing road endpoints x, y and its cost c (1<=x, y<=n, 0<=c<=10000). output for each test case output the cost of building cheapest road network or none if it is impossible. example input: 4 4 5 0 1 2 1 1 3 1 1 4 2 2 3 2 3 4 1000 4 5 1 1 2 1 1 3 1 1 4 2 2 3 2 3 4 1000 4 5 2 1 2 1 1 3 1 1 4 2 2 3 2 3 4 1000 4 5 3 1 2 1 1 3 1 1 4 2 2 3 2 3 4 1000 output: none 1003 5 4
skywalker successfully leads the rebel starship fleet to break the emperor's siege of the planet endor. the rebels, jubilant in their victory, return to their base on the moon of endor to pay their homage to princess leia. they fly towards the parking bay where there are n parking slots in a row. one by one n starships numbered s1 to sn enter the parking bay. each rebel ri heads to his favorite parking slot pi, and if it is free, he docks his starship there. otherwise, he continues further to the next free slot and occupies it. but if all succeeding slots are occupied, he leaves for good. how many sequences pi are such that every rebel can dock his starship? input description the first line of the input is a positive integer t ≤ 20, which is the number of test cases. the descriptions of the test cases follow one after the other. the description of each test case contains exactly one line (a positive integer), containing the value of n ≤ 1000000. output description the output consists of exactly t lines. the ith line should be ai%10007, where ai is the number of sequences in the ith case, and 'x%y' represents the remainder when x is divided by y. example input 2 1 2 output 1 3 explanation: in the given example, 11, 12 and 21 are the possible sequences.
mary, the well-known astronaut, had sent robot number 1 to mars finally. robot number 1 was so smart that he could make one robot per second. assume the time robot number 1 arrived was second 1. at second i, robot number 1 made a new robot: robot number i. (i>=2) the new robots started work as soon as he was produced successfully. robot number m only had a rest at second t, where t is a multiple of m. for example, robot number 3 worked at second 4, 5, 7, 8, ... and had a rest at second 6, 9, ... when a robot was having a rest, he could send his own informations to the newly produced robot. for example, when robot number 6 was produced successfully, robot number 2 and robot number 3 are having a rest, so robot number 6 would get information from robot number 2 and number 3. we call robot number 2 and number 3 are teachers of robot number 6. we call two robots are independent if each of them wasn't a teacher of the other one and they had no common teachers. please note that robot number 1 was independent to any other robots and wasn't a teacher of any other robots, since only robot number 1 could make robots. the good number of robot number m is the number of robots who was produced earlier than number m and independent to number m. here are some examples: the good number of robot number 1 is 0. the good number of robot number 2 is 1. number 1 was that robot. the good number of robot number 6 is 2. number 1 and number 5 were those robots. number 2 and number 3 were his teachers. number 4 and him had a common teacher: number 2. the robots had 3 kinds of occupations. to robot number m: if m can be written as the multiple of an even number of distinct odd primes, he was a businessman. if m can be written as the multiple of an odd number(1 included) of distinct odd primes, he was a hacker. all other robots were doctors. now blue mary was interesting to robot number m. she wants to know the sum of good numbers of all businessmen, hackers and doctors among robot number m and his teachers. she comes up with the answer quickly, and so can you. blue mary is so kind that she gives you the prime divisors of m and you can only tell her the answers modudo 10000. input the very first line contains a single integer t, the number of test cases.t blocks follow. for each block, the first line contains a single integer k.k lines follow, each contains two integers pi and ai separated by a single space. m = p1a1 * p2a2 * p3a3 * ... * pkak. you can assume that: all pi are distinct primes and are less than 10,000. p1 < p2 < p3 < ... n. all ai are positive and no more than 1,000,000. 1 <= k <= 1000. output for each test case, output 3 lines. the first line contains a single integer denotes to the sum of good numbers of all businessmen among robot number m and his teachers modudo 10000. the second line contains a single integer denotes to the sum of good numbers of all hackers among robot number m and his teachers modudo 10000. the third line contains a single integer denotes to the sum of good numbers of all doctors among robot number m and his teachers modudo 10000. example input: 1 3 2 1 3 2 5 1 output: 8 6 75 hints in the sample input, m=21*32*51=90. robot number 90 has 10 teachers. among robot number 90 and his teachers, robot number 15 is a businessman; number 3 and number 5 are hackers; all others are doctors, their numbers are 2, 6, 9, 10, 18, 30, 45, 90.
pride of the asia-pacific region is the newly constructed great circular zoo. situated on a small pacific island, it consists of a large circle of different enclosures, each containing its own exotic animal as illustrated below. you are in charge of public relations for the zoo, which means it is your job to keep people as happy as possible. a busload of schoolchildren has just arrived, and you are eager to please them. however, this is no easy task, there are animals that some children love, and there are animals that some children fear. for example, little alex loves monkeys and koalas because they are cute, but fears lions because of their sharp teeth. on the other hand, polly loves lions because of their beautiful manes, but fears koalas because they are extremely smelly. you have the option of removing some animals from their enclosures, so that children are not afraid. however, you are worried that if you remove too many animals then this will leave the children with nothing to look at. your task is to decide which animals to remove so that as many children can be made happy as possible. each child is standing outside the circle, where they can see five consecutive enclosures. you have obtained a list of which animals each child fears, and which animals each child loves. a child will be made happy if either at least one animal they fear is removed from their field of vision, or at least one animal they love is not removed from their field of vision. for example, consider the list of children and animals illustrated below: ----------------------------------------------------------------------- |child |enclosures visible |fears |loves | |alex |2, 3, 4, 5, 6 |enclosure 4 |enclosures 2, 6| |polly |3, 4, 5, 6, 7 |enclosure 6 |enclosure 4 | |chaitanya |6, 7, 8, 9, 10 |enclosure 9 |enclosures 6, 8| |hwan |8, 9, 10, 11, 12 |enclosure 9 |enclosure 12 | |ka-shu |12, 13, 14, 1, 2 |enclosures 12, 13, 2 |- | ----------------------------------------------------------------------- suppose you remove the animals from enclosures 4 and 12. this will make alex and ka-shu happy, because at least one animal that they fear has gone. this will also keep chaitanya happy, since both enclosures 6 and 8 still contain animals that he loves. however, both polly and hwan will be unhappy, since they cannot see any animals that they love but they can still see all the animals that they fear. this arrangement therefore gives a total of three happy children. now suppose you put these animals back into their enclosures, and remove the animals from enclosures 4 and 6 instead. alex and polly will be happy because the animals that they fear in enclosures 4 and 6 have gone. chaitanya will be happy because, even though animal 6 has gone, he can still see the animal in enclosure 8 which he loves. likewise, hwan will be happy because she can now see the animal in enclosure 12, which she loves. the only person unhappy will be ka-shu. finally, suppose you put the animals back once more and then remove only the animal from enclosure 13. ka-shu will now be happy since one animal that he fears has been removed, and alex, polly, chaitanya and hwan will all be happy since they can all see at least one animal that they love. thus this arrangement gives five happy children, the largest number possible. input multiple test cases, the number of them will be given at the very first line. for each test case: the first line will be of the form n c, where n is the number of animal enclosures (10 <= n <= 10 000) and c is the number of children (1 <= c <= 50 000). the enclosures are numbered 1, 2 ... n clockwise around the circle. following this will be c additional lines of input, where each line describes a single child. each of these lines will be of the form: e f l x1 x2 ... xf y1 y2 ... yl; where: e is the first enclosure that the child can see (1 <= e <= n). in other words, the child can see enclosures e, e + 1, e + 2, e + 3 and e + 4. note that numbers larger than n wrap back around the circle, so if n = 14 and e = 13 then the child can see enclosures 13, 14, 1, 2 and 3. f is the number of animals that the child fears, and l is the number of animals that the child loves. enclosures x1 ... xf contain the animals that the child fears (1 <= x1 ... xf <= n). enclosures y1 ... yl contain the animals that the child loves (1 <= y1 ... yl <= n). no two of the integers x1 ... xf,y1 ... yl are equal, and all of these integers describe enclosures that the child can see. children will be listed in sorted order according to the first enclosure e (so the child with lowest e will appear first and the child with largest e will appear last). note that more than one child may have the same first enclosure e. output output must consist of a single integer, giving the largest number of children that can be made happy. example input: 2 14 5 2 1 2 4 2 6 3 1 1 6 4 6 1 2 9 6 8 8 1 1 9 12 12 3 0 12 13 2 12 7 1 1 1 1 5 5 1 1 5 7 5 0 3 5 7 9 7 1 1 7 9 9 1 1 9 11 9 3 0 9 11 1 11 1 1 11 1 output: 5 6 explanation: the first sample case is the example discussed earlier, in which all c = 5 children can be made happy. the second sample case is an example in which it is impossible to make all c = 7 children happy. warning: large input/output data, be careful with certain languages
upon a time, there was a traveler. he plans to travel using stagecoaches (horse wagons). his starting point and destination are fixed, but he cannot determine his route. your job in this problem is to write a program which determines the route for him. there are several cities in the country, and a road network connecting them. if there is a road between two cities, one can travel by a stagecoach from one of them to the other. a coach ticket is needed for a coach ride. the number of horses is specified in each of the tickets. of course, with more horses, the coach runs faster. at the starting point, the traveler has a number of coach tickets. by considering these tickets and the information on the road network, you should find the best possible route that takes him to the destination in the shortest time. the usage of coach tickets should be taken into account. the following conditions are assumed. a coach ride takes the traveler from one city to another directly connected by a road. in other words, on each arrival to a city, he must change the coach. only one ticket can be used for a coach ride between two cities directly connected by a road. each ticket can be used only once. the time needed for a coach ride is the distance between two cities divided by the number of horses. the time needed for the coach change should be ignored. input the input consists of multiple datasets, each in the following format. the last dataset is followed by a line containing five zeros (separated by a space). n m p a b t1 t2 ... tn x1 y1 z1 x2 y2 z2 ... xp yp zp every input item in a dataset is a non-negative integer. if a line contains two or more input items, they are separated by a space. n is the number of coach tickets. you can assume that the number of tickets is between 1 and 8. m is the number of cities in the network. you can assume that the number of cities is between 2 and 30. p is the number of roads between cities, which may be zero. a is the city index of the starting city. b is the city index of the destination city. a is not equal to b. you can assume that all city indices in a dataset (including the above two) are between 1 and m. the second line of a dataset gives the details of coach tickets. ti is the number of horses specified in the i-th coach ticket (1 <= i <= n). you can assume that the number of horses is between 1 and 10. the following p lines give the details of roads between cities. the i-th road connects two cities with city indices xi and yi, and has a distance zi (1 <= i <= p). you can assume that the distance is between 1 and 100. no two roads connect the same pair of cities. a road never connects a city with itself. each road can be traveled in both directions. output for each dataset in the input, one line should be output as specified below. an output line should not contain extra characters such as spaces. if the traveler can reach the destination, the time needed for the best route (a route with the shortest time) should be printed. the answer should not have an error greater than 0.001. you may output any number of digits after the decimal point, provided that the above accuracy condition is satisfied. if the traveler cannot reach the destination, the string "impossible" should be printed. one cannot reach the destination either when there are no routes leading to the destination, or when the number of tickets is not sufficient. note that the first letter of "impossible" is in uppercase, while the other letters are in lowercase. example input: 3 4 3 1 4 3 1 2 1 2 10 2 3 30 3 4 20 2 4 4 2 1 3 1 2 3 3 1 3 3 4 1 2 4 2 5 2 4 3 4 1 5 5 1 2 10 2 3 10 3 4 10 1 2 0 1 2 1 8 5 10 1 5 2 7 1 8 4 5 6 3 1 2 5 2 3 4 3 4 7 4 5 3 1 3 25 2 4 23 3 5 22 1 4 45 2 5 51 1 5 99 0 0 0 0 0 output: 30.000 3.667 impossible impossible 2.856 note: since the number of digits after the decimal point is not specified, the above result is not the only solution. for example, the following result is also acceptable. 30.0 3.66667 impossible impossible 2.85595
equidivision of an n × n square array of cells is a partition of the n^2 cells in the array in exactly n sets, each one with n contiguous cells. two cells are contiguous when they have a common side. a good equidivision is composed of contiguous regions. the figures show a good and a wrong equidivision for a 5×5 square: note that in the second example the cells labeled with 4 describe three non-contiguous regions and cells labeled with 5 describe two non-contiguous regions. you must write a program that evaluates if an equidivision of the cells in a square array is good or not. input it is understood that a cell in an n×n square array is denoted by a pair (i, j), with 1 <= i, j <= n. the input file contains several test cases. each test case begins with a line indicating n, 0 < n < 100, the side of the square array to be partitioned. next, there are n − 1 lines, each one corresponding to one partition of the cells of the square, with some non-negative integer numbers. consecutive integers in a line are separated with a single blank character. a line of the form a1 a2 a3 a4 ... means that cells denoted with the pairs (a1, a2), (a3, a4), ... belong to one of the areas in the partition. the last area in the partition is defined by those cells not mentioned in the n − 1 given lines. if a case begins with n = 0 it means that there are no more cases to analyze. output for each test case good must be printed if the equidivision is good, in other case, wrong must be printed. the answers for the different cases must preserve the order of the input. example input: 2 1 2 2 1 5 1 1 1 2 1 3 3 2 2 2 2 1 4 2 4 1 5 1 3 1 4 5 5 2 5 3 5 5 5 4 2 5 3 4 3 5 4 3 4 4 5 1 1 1 2 1 3 3 2 2 2 2 1 3 1 4 1 5 1 4 2 4 5 5 2 5 3 5 5 5 4 2 4 1 4 3 5 4 3 4 4 0 output: wrong good wrong
most of you might already know, the intel-class hi-tech processors of today do a series of parallel tasks to help speedup instruction execution. the most complicated of those tasks is branch prediction. since the instruction chunks on a modern processor are broken down into independent chunks and executed for a speed up, there is always a requirement to predict what branch an execution path will take (before the actual operands required for the condition to be evaluated to select the branch, are available). this complex task, is not addressed to fullest level today, but heuristics (as always) have helped. the task we are going to consider now is much more simple compared to the actual branch prediction task. for our modelling, let us suppose that every instruction has the following syntax: all labels are strings of alphabets only. labels are case-sensitive. moreover the probability that a certain branch will be taken is p (it is equal for all branches). if a branch is taken, the point of execution (control) goes to the branched-label. otherwise the next statement in that order is executed. control starts at the "start" (lowercase) label and control ends at the "end" (lowercase) label. the branch-label of start and end are themselves, and when start is executed, the control goes to the next instruction, and when end is executed, processing ends, with 100% probability. the last statement in the program is always an “end”. it is required to find the expected number of times a statement executes. input t – the number of test cases; for each test case: 1st line contains one integer n (the number of lines to follow), one real p and one label l. each of the n lines that follow consist of instructions (two labels). output for each test case, output one line containing: "expected number of times label l is executed is r", where l - is the label given in the input r - is the number of times the label is expected to be executed. it must be printed with exactly five decimal places. constraints: t<=20 3<=n<=120. p lies between 0.01 and 0.99, i.e. no jump is 100% sure. also you can assume no label occurs on the jump side, without being defined throughout the program. each label is less than 10 characters in length. also each line has a distinct label associated with it. example sample input: 3 5 .5 b c start start start b c d c end end 5 .99 c start start a b b a c end end end 3 .5 label start start label label end end sample output: expected number of times label b is executed is 4.00000 expected number of times label c is executed is 1.00000 expected number of times label label is executed is 2.00000
a string, we need to find the total number of its distinct substrings. input t- number of test cases. t<=20; each test case consists of one string, whose length is <= 1000 output for each test case output one number saying the number of distinct substrings. example sample input: 2 ccccc ababa sample output: 5 9 explanation for the testcase with string ababa: len=1 : a,b len=2 : ab,ba len=3 : aba,bab len=4 : abab,baba len=5 : ababa thus, total number of distinct substrings is 9.
is in wonderland. it is march and march hare is raving mad. it begins to chase alice. alice runs as fast as she can, but she comes to the the edge of a quicksand pool. now this pool has several safe spots where she may comfortably step on without being swallowed by the quicksand. she may step onto any safe spot from solid ground, but thereafter she can jump from spot to spot only in a straight line, and she cant turn back. march hare is still hot on her heels, so she needs to know the maximum number of jumps she can make. input on the first line there will be a single integer n, denoting the number of test cases. each test case will consist of a single integer k by itself on a line, followed by k lines containing the x and y co-ordinates of the safe spots, separated by a single space. both coordinates are integer values. there are no leading or trailing spaces or blank lines. 0 < k â‰¤ 2200 output for each case print a single integer by itself on a line, with no leading or trailing spaces. do not print blank lines. example input: 2 5 0 0 1 1 2 2 4 8 2 75 3 0 0 1 2 3 4 output: 2 1
is a big palace in which rooms are constructed in the from of a square matrix. now these rooms have to be filled with people. as there are conflicts between people to maintain the equilibrium total number of people must be odd in every row and every column. a room can accommodate only a single person. given the size of palace n one has to find total number of ways people can be accommodated. input first line consists of an integer k and then k test cases follow. output for each test case you have to output the result%98777 in a separate line. example input: 1 3 output: 16
a and b be two strings made up of alphabets such that a = a[1-n], b = b[1-m]. we say b is a subsequence of a if there exists a sequence of indices i1 < i2 <..m of a such that a[ik] = b[k]. given b[1-m], a string of characters from some alphabets, b^i is defined as string with the characters of b each repeating i times. for example, (abbacc)^3 = aaabbbbbbaaacccccc. also, b^0 is the empty string. given strings x, y made up of characters from 'a' - 'z' find the maximum value of m such that x^m is a subsequence of y. input the first line of the input contains a positive integer t <= 20, denoting the no. of test cases. the following 2t lines contain the value of x and y for the cases. the description of the test cases follow one after the other. line 2k contains the value of x for case k; (1 <= k <= t) line 2k+1 contains the value of y for case k; (1 <= k <= t). the no. of characters in x , y will be <= 500010. output the output must contain t lines, each line corresponding to a test case. the value on the kth line should be the value of m for the kth pair of x and y. example input: 3 abc aabbcc abc bbccc abcdef abc output: 2 0 0
k-path cover of a directed graph is a set of exactly k of its edges chosen in such way that every two of them have different start vertices and every two of them have different end vertices. assuming that for each vertex we know its cost we can define cost of the edge as a sum of costs of its start and end. we can also define cost of a k-path cover as a sum of costs of its edges. your task is to find cheapest k-path cover for given directed graph with known costs of the vertices. a graph and its cheapest 4-path cover. input first line of input contains number of test cases c (1<=c<=20). each test case begins with k, number of vertices n and number of edges m (1<=k<=100, 1<=n<=10000, 0<=m<=1000000). next n lines contain costs of the vertices, each of them is an integer from [-100000,100000]. then m lines describing edges follow, each of them containing exactly two numbers representing its start and end vertices. vertices are numbered from 1 to n. output for each test case output cost of the cheapest k-path cover. when given graph has no k-path cover output none. example input: 1 4 6 9 5 4 6 10 2 3 1 2 1 4 2 4 3 2 4 3 5 4 6 3 5 6 6 5 output: 33
an n-vertex binary search tree t containing n keys 1, 2 ... n. a permutation p = [p1 ... pn] of the integers 1, 2 ... n is said to be consistent with the tree t if the tree can be built from the empty one as the result of inserting integers p1, p2 ... pn. find how many permutations are consistent with the tree t. illustration exactly 2 permutations are consistent with the tree in the figure below. task write a program that for each data set from a sequence of several data sets: reads from the input file a description of an input tree t, computes the number of permutations consistent with t, writes the result to output. input the first line of the input file contains one positive integer d not larger than 10. this is the number of data sets. the data sets follow. each set of data occupies two consecutive lines of the input file. the first line contains only one integer n, 1 <= n <= 30. this is the number of vertices of the tree. the second line contains a sequence of n integers separated by single spaces. the integers are keys in the input tree given in the prefix order. the first integer in the sequence is the key from the root of the tree. it is followed by the keys from the left subtree written in the prefix order. the sequence ends with the keys from the right subtree, also given in the prefix order. output for each i = 1 ... d, your program should write to the i-th line of output the number of permutations consistent with the tree described in the i-th data set. example sample input: 5 3 2 1 3 3 1 2 3 1 1 4 2 1 3 4 4 1 4 2 3 sample output: 2 1 1 3 1
two binary strings, a (of length 10) and b (of length 5), output 1 if b is a substring of a and 0 otherwise. please note, that the solution may only be submitted in the following languages: brainf**k, whitespace and intercal. input 24 lines consisting of pairs of binary strings a and b separated by a single space. output the logical value of: 'b is a substring of a'. example first two lines of input: 1010110010 10110 1110111011 10011 first two lines of output: 1 0
friday evening and jill hates two things which are common to all trains: they are always late. the schedule is always wrong. nevertheless, tomorrow in the early morning hours jill will have to travel from hamburg to darmstadt in order to get to the regional programming contest. since she is afraid of arriving too late and being excluded from the contest she is looking for the train which gets her to darmstadt as early as possible. however, she dislikes to get to the station too early, so if there are several schedules with the same arrival time then she will choose the one with the latest departure time. jill asks you to help her with her problem. you are given a set of railroad schedules from which you must compute the train with the earliest arrival time and the fastest connection from one location to another. one good thing: jill is very experienced in changing trains. she can do this instantaneously, i.e., in zero time!!! input the very first line of the input gives the number of scenarios. each scenario consists of three parts. part one lists the names of all cities connected by the railroads. it starts with a number 1 < c ≤ 100, followed by c lines containing city names. these names consist of letters. part two describes all the trains running during a day. it starts with a number t ≤ 1000 followed by t train descriptions. each of them consists of one line with a number ti ≤ 100 and ti more lines with a time and a city name, meaning that passengers can get on or off the train at that time at that city. part three consists of three lines: line one contains the earliest journey's starting time, line two the name of the city where she starts, and line three the destination city. the two cities are always different. output for each scenario print a line containing "scenario i", where i is the number of the scenario starting at 1. if a connection exists then print the two lines containing zero padded timestamps and locations as shown in the sample. use blanks to achieve the indentation. if no connection exists on the same day (i.e., arrival before midnight) then print a line containing "no connection". after each scenario print a blank line. example input: 2 3 hamburg frankfurt darmstadt 3 2 0949 hamburg 1006 frankfurt 2 1325 hamburg 1550 darmstadt 2 1205 frankfurt 1411 darmstadt 0800 hamburg darmstadt 2 paris tokyo 1 2 0100 paris 2300 tokyo 0800 paris tokyo output: scenario 1 departure 0949 hamburg arrival 1411 darmstadt scenario 2 no connection
polska english version for each index of n element permutation print m subsequent permutations (in separate lines) in lexicographical order starting from the one pointed by index. between outputs of subsequent tests there should be an empty line. next permutation to the last one is the first one. input t [number of tests <= 1000] n index m [2 <= n <= 100 - number of elements in permutation, 0 <= index < n! - index of the first permutation, 1 <= m <= 100 - how many permutations to print] output p1 p2 ... p(n-1) pn [permutations] p1 p2 ... pn p(n-1) p1 p2 ... p(n-1) pn [permutations] p1 p2 ... pn p(n-1) example input: 12 2 1 1 3 3 3 4 16 3 4 5 9 2 1 1 2 1 1 3 5 1 5 91 7 2 1 1 5 100 7 3 5 1 2 1 1 output: 2 1 2 3 1 3 1 2 3 2 1 3 4 1 2 3 4 2 1 4 1 2 3 1 4 3 2 2 1 3 4 2 1 4 3 2 3 1 4 2 3 4 1 2 4 1 3 2 4 3 1 3 1 2 4 3 1 4 2 2 1 2 1 3 2 1 4 5 1 3 2 4 5 2 1 3 4 5 2 3 1 4 5 3 1 2 4 5 3 2 1 5 1 2 3 4 5 1 2 4 3 2 1 5 1 4 2 3 5 1 4 3 2 5 2 1 3 4 5 2 1 4 3 5 2 3 1 4 5 2 3 4 1 5 2 4 1 3 3 2 1 2 1
is byteman’s birthday today. there are n children at his birthday party (including byteman). the children are numbered from 1 to n. byteman’s parents have prepared a big round table and they have placed n chairs around the table. when the children arrive, they take seats. the child number 1 takes one of the seats. then the child number 2 takes the seat on the left. then the child number 3 takes the next seat on the left, and so on. finally the child number n takes the last free seat, between the children number 1 and n−1. byteman’s parents know the children very well and they know that some of the children will be noisy, if they sit too close to each other. therefore the parents are going to reseat the children in a specific order. such an order can be described by a permutation p1, p2 ... pn (p1, p2 ... pn are distinct integers from 1 to n) — child pi (for i = 2, 3 ... n) should sit on child pi−1’s left, and child p1 should sit on child pn’s left. to seat all the children in the given order, the parents must move each child around the table to the left or to the right some number of seats. for each child, they must decide how the child will move — that is, they must choose a direction of movement (left or right) and distance (number of seats). on the given signal, all the children stand up at once, move to the proper places and sit down. the reseating procedure throws the birthday party into a mess. the mess is equal to the total distance any child moves. the children can be reseated in many ways. the parents choose one with minimum mess. help them to find such a way to reseat the children. input the first line of standard input contains one integer n (1 ≤ n ≤ 50000). the second line contains n integers p1, p2 ... pn, separated by single spaces. numbers p1, p2 ... pn form a permutation of the set {1,2 ... n} describing the desired order of the children. output the first and the only line of standard output should contain one integer: the minimum possible mess. example input: 5 1 5 4 3 2 output: 6
are given an unweighted, undirected tree. write a program to output the length of the longest path (from one node to another) in that tree. the length of a path in this case is number of edges we traverse from source to destination. input the first line of the input file contains one integer n --- number of nodes in the tree (0 < n <= 10000). next n-1 lines contain n-1 edges of that tree --- each line contains a pair (u, v) means there is an edge between node u and node v (1 <= u, v <= n). output print the length of the longest path on one line. example input: 3 1 2 2 3 output: 2
an infinite table with rows and columns numbered using the natural numbers. the following figure shows a procedure to traverse such a table assigning a consecutive natural number to each table cell: this enumeration of cells can be used to represent complex data types using natural numbers: a pair of natural numbers (i, j) is represented by the number corresponding to the cell in row i and column j. for instance, the pair (3,2) is represented by the natural number 17; this fact is noted by p2(3, 2) = 17. the pair representation can be used to represent n-tuples. a triplet (a, b, c) is represented by p2(a, p2(b, c)). a 4-tuple (a, b, c, d) is represented by p2(a, p2(b, p2(c, d))). this procedure can be generalized for an arbitrary n: pn(a1, ..., an) = p2(a1, pnâˆ’1(a2, .., an)), where pn denotes the n-tuple representation function, n >= 2. for example p3(2, 0, 1) = 12. a list of arbitrary length ha1, ..., ani is represented by l(ha1, ..., ani) = p2(n, pn(a1, ..., an)). for example, l(h0, 1i) = 12. the association of convex makers (acm) uses this clever enumeration scheme in a polygon representation system. the system can represent a polygon, defined by integer coordinates, using a natural number as follows: given a polygon defined by a vertex sequence h(x1, y1), ..., (xn, yn)i assign the natural number: l((hp2(x1, y1), ..., p2(xn, yn))). acm needs a program that, given a natural numbers that represents a polygon, calculates the area of the polygon. it is guaranteed that the given polygon is a simple one, i.e. its sides do not intersect. as an example of the problem, the triangle with vertices at (1,1), (2,0) and (0,0) is codified with the number 2141. the area of this triangle is 1. input the input consists of several test cases. each test case is given in a single line of the input by a natural number representing a polygon. the end of the test cases is indicated with *. output one line per test case, preserving the input order. each output line contains a decimal number telling the area of the corresponding encoded polygon. areas must be printed with 1 decimal place, truncating less significative decimal places. example input: 2141 206 157895330 * output: 1.0 0.5 1.0
order to celebrate the 2nd anniversary of travel agent spoj (safe – professional – hospitable – joyful), the management intend to hold free tours around cities for clients to make them more satisfied with spoj. a tour is a simple cycle, starting at any city (called a source-city) visits some other cities (each city must be visited at most once) and then returns to the source-city. the number of roads in the tour should be an even number because we are celebrating a 2nd anniversary, and 2 is even! since many tours in different areas of the country are planned, the cost of organising them could turn out quite high. hence, the management of spoj hope to find at least one 'reasonable' tour, which should have as small a number of roads as possible. you're given maps of the areas where spoj wants to hold free tours. for each map, help them figure out a reasonable tour. input the first line of input contains an integer t, the number of maps (t <= 5). t maps follow. for each map: in the first line there are 2 integers n – number of cities in that area, m – number of roads (1 <= n <= 8000, 0 <= m <= 10000) in the next m lines, the i-th line describes the i-th road: a line with two integers a b denotes a bidirectional road between city a and city b there is one blank line between successive tests. output for each map, if there is no tour satisfying the conditions, write "-1" (without quotes). otherwise, write one integer representing the number of roads in a reasonable tour, and in the next line show out the tour with form "source-city a b c ... source-city", that means the tour is source-city → city a → city b → … → source-city. if there are many tours satisfy in each map, any of them will be accepted. example input: 2 3 3 1 2 2 3 3 1 4 4 1 2 2 3 3 4 4 1 output: -1 4 1 2 3 4 1
